"""
Simple backtesting engine for the distance/time strategy.

This module allows you to run the `DistanceTimeStrategy` on historical
data (e.g., from a CSV file) without connecting to MetaTraderÂ 5.  It
uses a dummy order executor to record hypothetical trades so that you
can evaluate how the strategy would have performed.
"""

import pandas as pd
from dataclasses import dataclass
from typing import List, Optional

from .config import BotConfig
from .strategy import DistanceTimeStrategy
from .utils import debug


@dataclass
class TradeRecord:
    """Stores information about a hypothetical trade during backtest."""
    direction: str  # "buy" or "sell"
    entry_time: pd.Timestamp
    entry_price: float
    lot: float
    sl: float
    tp: float


class DummyExecutor:
    """Dummy order executor that logs trades instead of sending them to MT5."""

    def __init__(self, config: BotConfig):
        self.config = config
        self.trades: List[TradeRecord] = []

    def open_buy(self, bid: float, ask: float, pip: float) -> bool:
        lot = self.config.lot_size if self.config.mm <= 0 else 1.0
        # compute sl/tp in price units for logging
        sl_price = ask - self.config.stop_loss_pips * pip if self.config.stop_loss_pips > 0 else 0.0
        tp_price = ask + self.config.take_profit_pips * pip if self.config.take_profit_pips > 0 else 0.0
        self.trades.append(TradeRecord("buy", pd.Timestamp.utcnow(), ask, lot, sl_price, tp_price))
        debug(f"Backtest BUY signal at {ask}", self.config.symbol, self.config.enable_debug)
        return True

    def open_sell(self, bid: float, ask: float, pip: float) -> bool:
        lot = self.config.lot_size if self.config.mm <= 0 else 1.0
        sl_price = bid + self.config.stop_loss_pips * pip if self.config.stop_loss_pips > 0 else 0.0
        tp_price = bid - self.config.take_profit_pips * pip if self.config.take_profit_pips > 0 else 0.0
        self.trades.append(TradeRecord("sell", pd.Timestamp.utcnow(), bid, lot, sl_price, tp_price))
        debug(f"Backtest SELL signal at {bid}", self.config.symbol, self.config.enable_debug)
        return True

    def modify_trailing_stops(self, pip: float) -> None:
        # In backtest we don't move trailing stops; this can be extended
        pass


def run_backtest(csv_path: str, config: Optional[BotConfig] = None) -> List[TradeRecord]:
    """Run the strategy on historical bid/ask data from a CSV file.

    The CSV must contain at least the columns `time`, `bid` and `ask`.  The
    `time` column will be converted to a pandas `Timestamp` but is not used
    by the strategy.  Returns a list of `TradeRecord` instances representing
    signals generated by the strategy.
    """
    cfg = config or BotConfig()
    # Load data
    df = pd.read_csv(csv_path)
    if not {"time", "bid", "ask"}.issubset(df.columns):
        raise ValueError("CSV must contain 'time', 'bid' and 'ask' columns")
    # Use first row digits to compute pip value
    digits = len(str(df['bid'].iloc[0]).split(".")[-1])
    point = 10 ** (-digits)
    pip = point * 10 if digits in (5, 3) else point
    # Set up dummy executor and strategy
    executor = DummyExecutor(cfg)
    strategy = DistanceTimeStrategy(cfg, executor, pip)
    # Initialize reference prices
    strategy.reset_buy(df['bid'].iloc[0])
    strategy.reset_sell(df['ask'].iloc[0])
    # Run through rows
    for _, row in df.iterrows():
        bid = float(row['bid'])
        ask = float(row['ask'])
        strategy.update(bid, ask)
    return executor.trades
